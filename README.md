<h1 align="center">Hi, Ke Shen here ü§ó! </h1>
<h4 align="center">"Someone want to do something"</h4>

---



<h3>Who am IÔºü</h3>
<img align="right" alt="Hello World" width="30%" src="https://media.giphy.com/media/MeJgB3yMMwIaHmKD4z/giphy.gif">

- üë®‚Äçüíª ~~Geek~~/~~Hacker~~/~~Engineer~~/~~Scientist~~ 
- üôá Just a stupid **Computer Science Student**.
- üíÅ English name is **Ascar**. 
- ü§∑ Why not Oscar?
- üôÜ According to lexicographic order, 
- ü§¶ "A" makes me ranked **top** of ur contact list.
- üòä Yea, its me, a **maverick** and **funny** guy




<h3>My github stats</h3>

<img align="left" alt="Ascar's top language" width="50%" src="https://github-readme-stats.vercel.app/api/top-langs/?username=Ascarshen&layout=compact&show_icons=true">
<img align="left" alt="Ascar's github stat" width="50%" src="https://github-readme-stats.vercel.app/api?username=Ascarshen&count_private=true">



<h3>Where to find me</h3>
<p><a href="https://github.com/Ascarshen" target="_blank"><img alt="Github" src="https://img.shields.io/badge/GitHub-%2312100E.svg?&style=for-the-badge&logo=Github&logoColor=white" /></a></a> <a href="https://www.linkedin.com/in/shen-ke-ascsr-8689101a3/" target="_blank"><img alt="LinkedIn" src="https://img.shields.io/badge/linkedin-%230077B5.svg?&style=for-the-badge&logo=linkedin&logoColor=white" />
 <a href="mailto:ascarshen@gmail.com">
 <img alt="Email" src="https://img.shields.io/badge/Email-D14836?&style=for-the-badge&logo=Gmail&logoColor=white" />
 </a>
</p>


<br/>
<br/>
<!--
<hr>

<h2 align="center">Languages & Frameworks & Tools & Abilities</h2>

<p align="center">
  <code><img title="C" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/c.svg"></code>
  <code><img title="C++" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/cpp.svg"></code>
  <code><img title="C#" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/cSharp.svg"></code>
  <code><img title="Python" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/python.svg"></code>
  <code><img title="Django" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/django.svg"></code>
  <code><img title="Javascript" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/javascript.svg"></code>
  <code><img title="Problem Solving" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/problemSolving.png"></code>
  <code><img title="HTML5" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/html5.svg"></code>
  <code><img title="CSS" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/css.svg"></code>
  <code><img title="SASS" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/sass.svg"></code>
  <code><img title="AngularJS" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/angularjs.svg"></code>
  <code><img title=".NetCore" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/dotnetcore.svg"></code>
  <code><img title="JQuery" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/jquery.svg"></code>
  <code><img title="Java" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/java.svg"></code>
  <code><img title="JSON" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/json.svg"></code>
  <code><img title="Unity" height="25" src="https://github.com/zumrudu-anka/zumrudu-anka/blob/master/images/unity.svg"></code>
</p>

<hr>-->


**Languages and Tools:** 

![Java](https://img.shields.io/badge/-Java-black?logo=java&style=social)&nbsp;&nbsp;
![Spring](https://img.shields.io/badge/-Spring%20Framework-black?logo=spring&style=social)&nbsp;&nbsp;
![JavaScript](https://img.shields.io/badge/-JavaScript-black?logo=javascript&style=social)&nbsp;&nbsp;
![Python](https://img.shields.io/badge/-Python-black?logo=Python&style=social)&nbsp;&nbsp;
![C](https://img.shields.io/badge/-C-black?logo=c&style=social)&nbsp;&nbsp;
![jQuery](https://img.shields.io/badge/-jQuery-black?logo=jquery&style=social)&nbsp;&nbsp;
![Bootstrap](https://img.shields.io/badge/-Bootstrap-black?logo=bootstrap&style=social)&nbsp;&nbsp;
![MySQL](https://img.shields.io/badge/-MySQL-black?logo=mysql&style=social)&nbsp;&nbsp;
![Git](https://img.shields.io/badge/-Git-black?logo=git&style=social)&nbsp;&nbsp;
![GitHub](https://img.shields.io/badge/-GitHub-black?logo=github&style=social)&nbsp;&nbsp;
![LATEX](https://img.shields.io/badge/-LATEX-black?logo=latex&style=social)&nbsp;&nbsp;

#### :bar_chart: Weekly development breakdown

<!--START_SECTION:waka-->
```text
C       7 mins          ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñë‚ñë‚ñë   86.98 % 
Other   1 min           ‚ñà‚ñà‚ñà‚ñí‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë   13.02 % 
```
<!--END_SECTION:waka-->


![](https://img.shields.io/badge/Ascar-passing-green)
/*************************************************************************************|
|   1. YOU ARE NOT ALLOWED TO SHARE/PUBLISH YOUR CODE (e.g., post on piazza or online)|
|   2. Fill mipssim.c                                                                 |
|   3. Do not use any other .c files neither alter mipssim.h or parser.h              |
|   4. Do not include any other library files                                         |
|*************************************************************************************/

#include "mipssim.h"

#define BREAK_POINT 200000 // exit after so many cycles -- useful for debugging
#define I_TYPE 2
#define J_TYPE 3
#define ADDU 33   // 100001

// Global variables
char mem_init_path[1000];
char reg_init_path[1000];

uint32_t cache_size = 0;
struct architectural_state arch_state;

static inline uint8_t get_instruction_type(int opcode)
{
    switch (opcode) {
        /// opcodes are defined in mipssim.h

        case SPECIAL:
            return R_TYPE;
        case ADDU:
            return R_TYPE;
        case ADDI:
            return I_TYPE;
        case LW:
            return I_TYPE;
        case SW:
            return I_TYPE;
        case BEQ:
            return I_TYPE;
        case J:
            return J_TYPE;
        case SLT:
            return R_TYPE;

        case EOP:
            return EOP_TYPE;

        ///@students: fill in the rest

        default:
            assert(false);
    }
    assert(false);
}


void FSM()
{
    struct ctrl_signals *control = &arch_state.control;
    struct instr_meta *IR_meta = &arch_state.IR_meta;

    //reset control signals
    memset(control, 0, (sizeof(struct ctrl_signals)));

    int opcode = IR_meta->opcode;
    int state = arch_state.state;
    switch (state) {
        case INSTR_FETCH:
            control->MemRead = 1;
            control->ALUSrcA = 0;
            control->IorD = 0;
            control->IRWrite = 1;
            control->ALUSrcB = 1;
            control->ALUOp = 0;
            control->PCWrite = 1;
            control->PCSource = 0;
            state = DECODE;
            break;
        case DECODE:
            control->ALUSrcA = 0;
            control->ALUSrcB = 3;
            control->ALUOp = 0;
            if (IR_meta->type == R_TYPE) state = EXEC;
            else if (opcode == ADDI) state = I_TYPE_EXEC;
            else if (opcode == BEQ) state = BRANCH_COMPL;
            else if (opcode == LW || opcode == SW) state = MEM_ADDR_COMP;
            else if (opcode == J) state = JUMP_COMPL;
            else if (opcode == EOP) state = EXIT_STATE;
            else assert(false);
            break;

        case MEM_ADDR_COMP:
            control->ALUSrcA = 1;
            control->ALUSrcB = 2;
            control->ALUOp = 0;
            if (opcode == LW) state = MEM_ACCESS_LD;
            if (opcode == SW) state = MEM_ACCESS_ST;
            break;
        case MEM_ACCESS_LD:
            control->IorD = 1;
            control->MemRead = 1;
            state = WB_STEP;
            break;
        case MEM_ACCESS_ST:
            control->IorD = 1;
            control->MemWrite = 1;
            state = INSTR_FETCH;
            break;
        case EXEC:
            control->ALUSrcA = 1;
            control->ALUSrcB = 0;
            control->ALUOp = 2;
            state = R_TYPE_COMPL;
            break;
        case R_TYPE_COMPL:
            control->RegDst = 1;
            control->RegWrite = 1;
            control->MemtoReg = 0;
            state = INSTR_FETCH;
            break;
        case I_TYPE_EXEC:
            control->ALUSrcA = 1;
            control->ALUSrcB = 2;
            control->ALUOp = 0;
            state = I_TYPE_COMPL;
            break;
        case I_TYPE_COMPL:
            control->RegDst = 0;
            control->RegWrite=1;
            control->MemtoReg = 0;
            state = INSTR_FETCH;
            break;
        case BRANCH_COMPL:
            control->ALUSrcA = 1;
            control->ALUSrcB = 0;
            control->ALUOp = 1;
            control->PCWriteCond = 1;
            control->PCSource = 1;
            state = INSTR_FETCH;
            break;
        case JUMP_COMPL:
            control->PCWrite = 1;
            control->PCSource = 2;
            state = INSTR_FETCH;
            break;
        case WB_STEP:
            control->RegDst = 0;
            control->RegWrite = 1;
            control->MemtoReg = 1;
            state = INSTR_FETCH;
            break;
        default: assert(false);
    }
    arch_state.state = state;
}


void instruction_fetch()
{
    if (arch_state.control.MemRead) {
        int address = arch_state.curr_pipe_regs.pc;
        arch_state.next_pipe_regs.IR = memory_read(address);

    }
}

void decode_and_read_RF()
{
    int read_register_1 = arch_state.IR_meta.reg_21_25;
    int read_register_2 = arch_state.IR_meta.reg_16_20;
    check_is_valid_reg_id(read_register_1);
    check_is_valid_reg_id(read_register_2);
    arch_state.next_pipe_regs.A = arch_state.registers[read_register_1];
    arch_state.next_pipe_regs.B = arch_state.registers[read_register_2];
}

void execute()
{
    struct ctrl_signals *control = &arch_state.control;
    struct instr_meta *IR_meta = &arch_state.IR_meta;
    struct pipe_regs *curr_pipe_regs = &arch_state.curr_pipe_regs;
    struct pipe_regs *next_pipe_regs = &arch_state.next_pipe_regs;

    int alu_opA = control->ALUSrcA == 1 ? curr_pipe_regs->A : curr_pipe_regs->pc;
    int alu_opB = 0;
    int immediate = IR_meta->immediate;
    int shifted_immediate = (immediate) << 2;
    switch (control->ALUSrcB) {
        case 0:
            alu_opB = curr_pipe_regs->B;
            break;
        case 1:
            alu_opB = WORD_SIZE;
            break;
        case 2:
            alu_opB = immediate;
            break;
        case 3:
            alu_opB = shifted_immediate;
            break;
        default:
            assert(false);
    }


    switch (control->ALUOp) {
        case 0:
            next_pipe_regs->ALUOut = alu_opA + alu_opB;
            if (control->IorD == 1){
                next_pipe_regs->ALUOut = curr_pipe_regs->ALUOut;
            }
            break;
        case 1:
            next_pipe_regs->ALUOut = alu_opA - alu_opB;

            break;
        case 2:
            if (IR_meta->function == ADD)
                next_pipe_regs->ALUOut = alu_opA + alu_opB;
            else if (IR_meta->function == ADDU)
                next_pipe_regs->ALUOut = alu_opA + alu_opB;
            else if (IR_meta->function == SLT)
                next_pipe_regs->ALUOut = alu_opA<alu_opB;
            else
                assert(false);
            break;
        default:
            assert(false);
    }

    // PC calculation
    switch (control->PCSource) {
        case 0:
            next_pipe_regs->pc = next_pipe_regs->ALUOut;
            break;
        case 1:
            if ((!next_pipe_regs->ALUOut && control->PCWriteCond) || control ->PCWrite) {
                next_pipe_regs->pc = curr_pipe_regs->ALUOut;
            }else if ((next_pipe_regs->ALUOut && control->PCWriteCond) || control ->PCWrite){
                next_pipe_regs->pc = curr_pipe_regs->pc;
            }else assert(false);
            break;
        case 2:
            next_pipe_regs->pc = IR_meta->jmp_offset<<2;
            break;
        default:
            assert(false);
    }
}


void memory_access() {
  ///@students: appropriate calls to functions defined in memory_hierarchy.c must be added
  struct ctrl_signals *control = &arch_state.control;
  struct instr_meta *IR_meta = &arch_state.IR_meta;
  struct pipe_regs *curr_pipe_regs = &arch_state.curr_pipe_regs;
  struct pipe_regs *next_pipe_regs = &arch_state.next_pipe_regs;
  if (control->MemRead && control->IorD) {
      curr_pipe_regs->MDR = memory_read(curr_pipe_regs->ALUOut);


  }else if (control->MemWrite && control->IorD) {
      curr_pipe_regs->MDR = arch_state.registers[IR_meta->reg_16_20];
      memory_write(curr_pipe_regs->ALUOut, curr_pipe_regs->MDR);
      printf("The address is :%d, the data is : %d \n", curr_pipe_regs->ALUOut, curr_pipe_regs->MDR);
  }

}

void write_back()
{
    if (arch_state.control.RegWrite) {
        int write_reg_id;
        if (arch_state.control.RegDst == 1)
            write_reg_id = arch_state.IR_meta.reg_11_15;
        else if (arch_state.control.RegDst == 0)
            write_reg_id = arch_state.IR_meta.reg_16_20;
        check_is_valid_reg_id(write_reg_id);
        int write_data;
        if (arch_state.control.MemtoReg==1)
            write_data = arch_state.curr_pipe_regs.MDR;
        else
            write_data =  arch_state.curr_pipe_regs.ALUOut;
        if (write_reg_id > 0) {
            arch_state.registers[write_reg_id] = write_data;
            printf("Reg $%u = %d \n", write_reg_id, write_data);
        } else printf("Attempting to write reg_0. That is likely a mistake \n");
    }
}


void set_up_IR_meta(int IR, struct instr_meta *IR_meta)
{
    IR_meta->opcode = get_piece_of_a_word(IR, OPCODE_OFFSET, OPCODE_SIZE);
    IR_meta->immediate = get_sign_extended_imm_id(IR, IMMEDIATE_OFFSET);
    IR_meta->function = get_piece_of_a_word(IR, 0, 6);
    IR_meta->jmp_offset = get_piece_of_a_word(IR, 0, 26);
    IR_meta->reg_11_15 = (uint8_t) get_piece_of_a_word(IR, 11, REGISTER_ID_SIZE);
    IR_meta->reg_16_20 = (uint8_t) get_piece_of_a_word(IR, 16, REGISTER_ID_SIZE);
    IR_meta->reg_21_25 = (uint8_t) get_piece_of_a_word(IR, 21, REGISTER_ID_SIZE);
    IR_meta->type = get_instruction_type(IR_meta->opcode);

    switch (IR_meta->opcode) {
        case SPECIAL:
            if (IR_meta->function == ADD)
                printf("Executing ADD(%d), $%u = $%u + $%u (function: %u) \n",
                       IR_meta->opcode,  IR_meta->reg_11_15, IR_meta->reg_21_25,  IR_meta->reg_16_20, IR_meta->function);
            else if (IR_meta->function == ADDU)
                printf("Executing ADDU(%d), $%u = $%u + $%u (function: %u) \n",
                       IR_meta->opcode, IR_meta->reg_11_15, IR_meta->reg_21_25, IR_meta->reg_16_20, IR_meta->function);
            else if (IR_meta->function == SLT)
                printf("Executing SLT(%d), $%u = $%u < $%u (function: %u) \n",
                       IR_meta->opcode, IR_meta->reg_11_15, IR_meta->reg_21_25, IR_meta->reg_16_20, IR_meta->function);
            break;
        case ADDI:
            printf("Executing ADDI(%d), $%u = $%u + %d (function: %u) \n",
                   IR_meta->opcode, IR_meta->reg_16_20, IR_meta->reg_21_25, IR_meta->immediate, IR_meta->function);
            break;
        case LW:
            printf("Executing LW(%d), $%u = %d($%u) (function: %u) \n",
                   IR_meta->opcode, IR_meta->reg_16_20, IR_meta->immediate, IR_meta->reg_21_25,  IR_meta->function);
            break;
        case SW:
            printf("Executing SW(%d), %d($%u) = $%u (function: %u) \n",
                   IR_meta->opcode, IR_meta->immediate, IR_meta->reg_21_25, IR_meta->reg_16_20, IR_meta->function);
            break;
        case BEQ:
            printf("Executing BEQ(%d), $%u == $%u? go pc+%d : pc + 4 (function: %u) \n",
                   IR_meta->opcode, IR_meta->reg_16_20, IR_meta->reg_21_25, IR_meta->immediate<<2, IR_meta->function);
            break;
        case J:
            printf("Executing J(%d), jump to %d (function: %u) \n",
                   IR_meta->opcode, IR_meta->jmp_offset, IR_meta->function);
            break;
        case EOP:
            printf("Executing EOP(%d) \n", IR_meta->opcode);
            break;
        default: assert(false);
    }
}

void assign_pipeline_registers_for_the_next_cycle()
{
    struct ctrl_signals *control = &arch_state.control;
    struct instr_meta *IR_meta = &arch_state.IR_meta;
    struct pipe_regs *curr_pipe_regs = &arch_state.curr_pipe_regs;
    struct pipe_regs *next_pipe_regs = &arch_state.next_pipe_regs;

    if (control->IRWrite) {
        curr_pipe_regs->IR = next_pipe_regs->IR;
        printf("PC %d: ", curr_pipe_regs->pc / 4);
        set_up_IR_meta(curr_pipe_regs->IR, IR_meta);
    }
    curr_pipe_regs->ALUOut = next_pipe_regs->ALUOut;
    curr_pipe_regs->A = next_pipe_regs->A;
    curr_pipe_regs->B = next_pipe_regs->B;
    if (control->PCWrite) {
        check_address_is_word_aligned(next_pipe_regs->pc);
        curr_pipe_regs->pc = next_pipe_regs->pc;
    }
    if (control->PCWriteCond){
        check_address_is_word_aligned(next_pipe_regs->pc);
        curr_pipe_regs->pc = next_pipe_regs->pc;
    }
}


int main(int argc, const char* argv[])
{
    /*--------------------------------------
    /------- Global Variable Init ----------
    /--------------------------------------*/
    parse_arguments(argc, argv);
    arch_state_init(&arch_state);
    ///@students WARNING: Do NOT change/move/remove main's code above this point!
    while (true) {

        ///@students: Fill/modify the function bodies of the 7 functions below,
        /// Do NOT modify the main() itself, you only need to
        /// write code inside the definitions of the functions called below.

        FSM();

        instruction_fetch();

        decode_and_read_RF();

        execute();

        memory_access();

        write_back();

        assign_pipeline_registers_for_the_next_cycle();


       ///@students WARNING: Do NOT change/move/remove code below this point!
        marking_after_clock_cycle();
        arch_state.clock_cycle++;
        // Check exit statements
        if (arch_state.clock_cycle == 500)
            break;
        if (arch_state.state == EXIT_STATE) { // I.E. EOP instruction!
            printf("Exiting because the exit state was reached \n");
            break;
        }
        if (arch_state.clock_cycle == BREAK_POINT) {
            printf("Exiting because the break point (%u) was reached \n", BREAK_POINT);
            break;
        }
    }
    marking_at_the_end();
}
„ÄÅ„ÄÅ
/*************************************************************************************|
|   1. YOU ARE NOT ALLOWED TO SHARE/PUBLISH YOUR CODE (e.g., post on piazza or online)|
|   2. Fill mipssim.c                                                                 |
|   3. Do not use any other .c files neither alter mipssim.h or parser.h              |
|   4. Do not include any other library files                                         |
|   -----------------DO NOT EDIT THIS FILE!!!!----------------------------------------|
|*************************************************************************************/
#pragma once
#include <math.h>
#include "parser.h"

////////////////////////////////////////////////////////
/// Struct Definitions
////////////////////////////////////////////////////////
struct memory_stats_t{
    uint64_t lw_total;
    uint64_t sw_total;

    /// @students: your cache implementation must increment these properly
    uint64_t lw_cache_hits;
    uint64_t sw_cache_hits;
};


struct instr_meta{
    uint32_t instr;
    int immediate; // sing extended
    int opcode;
    uint8_t reg_21_25;
    uint8_t reg_16_20;
    uint8_t reg_11_15;
    uint8_t  type; //
    int function;
    int jmp_offset;
};

struct ctrl_signals {
    // 1-bit signals
    int RegDst;
    int RegWrite;
    int ALUSrcA;

    int MemRead;
    int MemWrite;
    int MemtoReg;

    int IorD;
    int IRWrite;

    int PCWrite;
    int PCWriteCond;

    //2-bit signals
    int ALUOp;
    int ALUSrcB;
    int PCSource;

};

struct pipe_regs {
    int pc;
    int IR;
    int A;
    int B;
    int ALUOut;
    int MDR;
};


struct architectural_state {
    int state;
    uint64_t clock_cycle;
    struct ctrl_signals control;
    struct instr_meta IR_meta;
    struct pipe_regs curr_pipe_regs;
    struct pipe_regs next_pipe_regs;
    int bits_for_cache_tag;
    struct memory_stats_t mem_stats;
    int registers[REGISTER_NUM];
    uint32_t *memory;
};

////////////////////////////////////////////////////////
/// Global Variables
////////////////////////////////////////////////////////
extern char mem_init_path[];
extern char reg_init_path[];
extern uint32_t  cache_size;
extern struct architectural_state arch_state;


////////////////////////////////////////////////////////
/// Memory Functions
////////////////////////////////////////////////////////
void memory_state_init(struct architectural_state *);
int  memory_read(int address);
void memory_write (int address, int write_data);

////////////////////////////////////////////////////////////////
/// Marking Functions --> Do not (re)move those functions
////////////////////////////////////////////////////////////////
static inline void marking_after_clock_cycle() { }
static inline void marking_at_the_end(){ }


static inline void instruction_parser(uint32_t *memory,  char* instr_file_path,
                                      uint32_t *registers, char* reg_file_path)
{
    int instr_count = iterate_file(memory, instr_file_path, per_line_binary_parser, MEMORY_WORD_NUM);

    uint32_t *registers_but_zero = &registers[1]; // Init registers from $1 onwards
    int reg_count = iterate_file(registers_but_zero, reg_file_path, per_line_decimal_parser, REGISTER_NUM - 1);

    printf(" ~~~ Loaded Memory   :\n");
    print_uint32_bin_array(memory, instr_count);
    printf(" ~~~ Loaded Registers: (print starts from $1)\n");
    print_uint32_bin_array(registers_but_zero, reg_count);
}



////////////////////////////////////////////////////////
/// Helper Defines & Functions
////////////////////////////////////////////////////////

//Offsets and sizes
#define OPCODE_OFFSET 26
#define OPCODE_SIZE 6 // 6 bits to encode an opcode (26-31)
#define REGISTER_ID_SIZE 5 // 5 bits to encode an opcode
#define IMMEDIATE_OFFSET 0


//Instruction types
#define R_TYPE 1
#define EOP_TYPE 6


// OPCODES
#define SPECIAL 0 // 000000
#define ADD 32    // 100000
#define ADDI 8    // 001000
#define LW 35     // 100011
#define SW 43     // 101011
#define BEQ  4    // 000100
#define J 2       // 000010
#define SLT 42    // 101010
#define EOP 63    // 111111


// FSM STATES
#define INSTR_FETCH 0
#define DECODE 1
#define MEM_ADDR_COMP 2
#define MEM_ACCESS_LD 3
#define WB_STEP 4
#define MEM_ACCESS_ST 5
#define EXEC 6
#define R_TYPE_COMPL 7
#define BRANCH_COMPL 8
#define JUMP_COMPL 9
#define EXIT_STATE 10
#define I_TYPE_EXEC 11
#define I_TYPE_COMPL 12


static inline void check_is_valid_reg_id(int reg_id)
{
    assert(reg_id >= 0);
    assert(reg_id < REGISTER_NUM);
}

static inline void check_address_is_word_aligned(int address)
{
    assert(address >= 0);
    assert(address % WORD_SIZE == 0);
    assert(address <= MEMORY_WORD_NUM);
}



// Used to get a sign extended immediate (sign extension from 16 bit to 32)
static inline int get_sign_extended_imm_id(int instr, uint8_t offset)
{
    short int imm = (short int)(instr >> offset);
    return (int) imm;
}


static inline int get_piece_of_a_word(int word, uint8_t start, uint8_t size)
{
    int mask = 1 << size;
    mask--;
    return (word >> start) & mask;
}


static inline void parse_arguments(int argc, const char* argv[])
{
    assert(argc == 4 && "Three arguments are expected in the following order: " &&
           "1. <cache_size> (in bytes, use 0 to disable cache)" &&
           "2. <init_memory_file_path>" &&
           "3. <init_register_file_path>");
    sscanf(argv[1],"%d", &cache_size); // Use cache size to dynamically allocate the size of your cache
    sscanf(argv[2],"%s", mem_init_path);
    sscanf(argv[3],"%s", reg_init_path);
    printf("Cache size: %d, Mem path: %s, Reg path: %s\n", cache_size, mem_init_path, reg_init_path);

}


static inline void arch_state_init(struct architectural_state* arch_state_ptr)
{

    memset(arch_state_ptr, 0, sizeof(struct architectural_state));
    memory_state_init(arch_state_ptr);
    arch_state_ptr->state = INSTR_FETCH;
    // Loads the "binary" into the memory array, and init registers
    instruction_parser(arch_state_ptr->memory, mem_init_path,
                       (uint32_t *) arch_state_ptr->registers, reg_init_path);

}

static inline void memory_stats_init(struct architectural_state *state, int bits_for_cache_tag)
{
    state->mem_stats.sw_total= 0;
    state->mem_stats.lw_total= 0;
    state->mem_stats.lw_cache_hits = 0;
    state->mem_stats.sw_cache_hits = 0;
    state->bits_for_cache_tag = bits_for_cache_tag;
}

